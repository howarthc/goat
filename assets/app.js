// GOAT v1.0 (client)
const VERSION='1.0';const statusEl=document.getElementById('status');const gridEl=document.getElementById('grid');const form=document.getElementById('loc');const postcodeInput=document.getElementById('postcode');const fmtMoney=p=>`${Number(p).toFixed(1)}p`;const tzOpts={hour:'2-digit',minute:'2-digit'};function getPostcodeFromURL(){const u=new URL(location.href);return(u.searchParams.get('postcode')||'').trim()}function setPostcodeInURL(pc){const u=new URL(location.href);u.searchParams.set('postcode',pc);history.replaceState({},"",u.toString())}function loadInitialPostcode(){return getPostcodeFromURL()||localStorage.getItem('goat_postcode')||''}function savePostcode(pc){localStorage.setItem('goat_postcode',pc);setPostcodeInURL(pc)}
const stops=[{v:-10,c:[65,105,225]},{v:0,c:[255,255,255]},{v:13,c:[255,255,0]},{v:27,c:[255,0,0]},{v:100,c:[10,30,120]}];function lerp(a,b,t){return a+(b-a)*t}function lerpColor(c1,c2,t){return[Math.round(lerp(c1[0],c2[0],t)),Math.round(lerp(c1[1],c2[1],t)),Math.round(lerp(c1[2],c2[2],t))]}function colorForValue(v){if(v<=stops[0].v)return`rgb(${stops[0].c.join(',')})`;if(v>=stops[stops.length-1].v)return`rgb(${stops[stops.length-1].c.join(',')})`;for(let i=0;i<stops.length-1;i++){const a=stops[i],b=stops[i+1];if(v>=a.v&&v<=b.v){const t=(v-a.v)/(b.v-a.v);const c=lerpColor(a.c,b.c,t);return`rgb(${c.join(',')})`}}return`rgb(${stops[stops.length-1].c.join(',')})`}function textColorForBg(rgbStr){const m=rgbStr.match(/rgb\((\d+),(\d+),(\d+)\)/);if(!m)return'#111';const r=+m[1],g=+m[2],b=+m[3];const L=0.2126*r+0.7152*g+0.0722*b;return L<140?'#fff':'#111'}
function toRad(d){return d*Math.PI/180}function julianDay(date){const y=date.getUTCFullYear();const m=date.getUTCMonth()+1;const D=date.getUTCDate();const A=Math.floor(y/100);const B=2-A+Math.floor(A/4);return Math.floor(365.25*(y+4716))+Math.floor(30.6001*(m+1))+D+B-1524.5}function solarMeanAnomaly(J){return toRad((357.5291+0.98560028*(J-2451545))%360)}function eclipticLongitude(M){const C=toRad(1.9148*Math.sin(M)+0.0200*Math.sin(2*M)+0.0003*Math.sin(3*M));const P=toRad(102.9372);return(M+C+P+Math.PI)%(2*Math.PI)}function solarTransitJ(Js,M,L){return 2451545+Js+0.0053*Math.sin(M)-0.0069*Math.sin(2*L)}function hourAngle(lat,dec){return Math.acos((Math.sin(toRad(-0.83))-Math.sin(lat)*Math.sin(dec))/(Math.cos(lat)*Math.cos(dec)))}function declination(L){return Math.asin(Math.sin(L)*Math.sin(toRad(23.44)))}function sunriseSunset(date,latDeg,lonDeg){const J=julianDay(date);const n=Math.round(J-2451545-0.0009-lonDeg/360);const Js=0.0009+lonDeg/360+n;const M=solarMeanAnomaly(2451545+Js);const L=eclipticLongitude(M);const dec=declination(L);const H=hourAngle(toRad(latDeg),dec);const Jrise=solarTransitJ(Js-H/(2*Math.PI),M,L);const Jset=solarTransitJ(Js+H/(2*Math.PI),M,L);function jdToDate(JD){const Z=Math.floor(JD+0.5);const F=JD+0.5-Z;const A=Z;const B=A+1524;const C=Math.floor((B-122.1)/365.25);const D=Math.floor(365.25*C);const E=Math.floor((B-D)/30.6001);const day=B-D-Math.floor(30.6001*E)+F;const month=(E<14)?E-1:E-13;const year=(month>2)?C-4716:C-4715;const dayFrac=day%1;const dayInt=Math.floor(day);const hours=Math.floor(dayFrac*24);const minutes=Math.floor((dayFrac*24-hours)*60);const seconds=Math.round((((dayFrac*24-hours)*60)-minutes)*60);return new Date(Date.UTC(year,month-1,dayInt,hours,minutes,seconds))}return{sunrise:jdToDate(Jrise),sunset:jdToDate(Jset)}}
let sunCache={};async function getSunTimes(dateLocal){let lat=51.5074,lon=-0.1278;if(navigator.geolocation){try{const pos=await new Promise((res,rej)=>navigator.geolocation.getCurrentPosition(res,rej,{timeout:2000}));lat=pos.coords.latitude;lon=pos.coords.longitude}catch(e){}}const key=dateLocal.toDateString()+':'+lat.toFixed(2)+':'+lon.toFixed(2);if(sunCache[key])return sunCache[key];const dateUTC=new Date(Date.UTC(dateLocal.getFullYear(),dateLocal.getMonth(),dateLocal.getDate()));const {sunrise,sunset}=sunriseSunset(dateUTC,lat,lon);const sr=new Date(sunrise.getTime()+(dateLocal.getTimezoneOffset()*-60000));const ss=new Date(sunset.getTime()+(dateLocal.getTimezoneOffset()*-60000));sunCache[key]={sunrise:sr,sunset:ss};return sunCache[key]}
async function safeJson(res){const ct=res.headers.get('content-type')||'';const text=await res.text();if(!ct.includes('application/json')){throw new Error(`Expected JSON but got: ${text.split('\n')[0].slice(0,160)}`)}try{return JSON.parse(text)}catch(e){throw new Error(`Bad JSON: ${e.message}`)}}
async function getGspByPostcode(pc){const res=await fetch(`api/region.php?postcode=${encodeURIComponent(pc)}`,{cache:'no-store'});if(!res.ok)throw new Error(`Region lookup failed: ${res.status}`);const j=await safeJson(res);if(!j.gsp)throw new Error('Could not resolve region');return j.gsp}
async function fetchRates(gsp,fromISO,toISO){const qs=new URLSearchParams({gsp,from:fromISO,to:toISO});const res=await fetch(`api/agile.php?${qs.toString()}`,{cache:'no-store'});if(!res.ok)throw new Error(`Rates fetch failed: ${res.status}`);return safeJson(res)}
function computeSummary(rates){const now=Date.now();let currentIdx=-1,nextIdx=-1,cheapIdx=-1,expIdx=-1;let cheapVal=Infinity,expVal=-Infinity;for(let i=0;i<rates.length;i++){const s=Date.parse(rates[i].start),e=Date.parse(rates[i].end),v=Number(rates[i].price_inc_vat_p_per_kwh);if(now>=s&&now<e)currentIdx=i;if(s>now&&nextIdx===-1)nextIdx=i;if(s>=now&&v<cheapVal){cheapVal=v;cheapIdx=i}if(s>=now&&v>expVal){expVal=v;expIdx=i}}return{currentIdx,nextIdx,cheapIdx,expIdx}}
function setTopCell(idBase,startISO,endISO,price){const timeEl=document.getElementById(`${idBase}-time`);const priceEl=document.getElementById(`${idBase}-price`);const cell=document.getElementById(`cell-${idBase}`);const t=(iso)=>new Date(iso).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'});const bg=colorForValue(price);const fg=textColorForBg(bg);cell.style.background=bg;cell.style.color=fg;timeEl.textContent=`${t(startISO)}–${t(endISO)}`;priceEl.textContent=fmtMoney(price)}
async function render(rates){if(!Array.isArray(rates)||!rates.length)throw new Error('No data returned');rates=rates.slice().sort((a,b)=>a.start.localeCompare(b.start));const now=Date.now();rates=rates.filter(r=>Date.parse(r.end)>now);const {currentIdx,nextIdx,cheapIdx,expIdx}=computeSummary(rates);if(currentIdx>=0){const r=rates[currentIdx];setTopCell('current',r.start,r.end,Number(r.price_inc_vat_p_per_kwh))}if(nextIdx>=0){const r=rates[nextIdx];setTopCell('next',r.start,r.end,Number(r.price_inc_vat_p_per_kwh))}if(cheapIdx>=0){const r=rates[cheapIdx];setTopCell('cheapest',r.start,r.end,Number(r.price_inc_vat_p_per_kwh))}if(expIdx>=0){const r=rates[expIdx];setTopCell('expensive',r.start,r.end,Number(r.price_inc_vat_p_per_kwh))}let html=`<tr><th>Start</th><th>End</th><th>Price</th><th>Trend</th></tr>`;const dayMap={};async function dayInfo(d){const k=d.toDateString();if(!dayMap[k])dayMap[k]=await getSunTimes(d);return dayMap[k]}for(let i=0;i<rates.length;i++){const r=rates[i];const sDate=new Date(r.start);const eDate=new Date(r.end);const {sunrise:srS,sunset:ssS}=await dayInfo(sDate);const {sunrise:srE,sunset:ssE}=await dayInfo(eDate);const sStr=sDate.toLocaleTimeString('en-GB',tzOpts);const eStr=eDate.toLocaleTimeString('en-GB',tzOpts);const val=Number(r.price_inc_vat_p_per_kwh);const bg=colorForValue(val);const fg=textColorForBg(bg);let trendHtml='<span class=\"trend-same\">-</span>';if(i>0){const prev=Number(rates[i-1].price_inc_vat_p_per_kwh);const diff=val-prev;if(Math.abs(diff)<0.001)trendHtml='<span class=\"trend-same\">-</span>';else if(diff>0)trendHtml='<span class=\"trend-up\">▲</span>';else trendHtml='<span class=\"trend-down\">▼</span>'}const isNow=now>=Date.parse(r.start)&&now<Date.parse(r.end);const nowCls=isNow?' class=\"now\"':'';const startIsDay=(sDate>=srS&&sDate<ssS);const endIsDay=(eDate>=srE&&eDate<ssE);const startDayCls=startIsDay?'day':'night';const endDayCls=endIsDay?'day':'night';html+=`<tr${nowCls}><td class=\"time-start ${startDayCls}\">${sStr}</td><td class=\"time-end ${endDayCls}\">${eStr}</td><td class=\"price-cell\" style=\"background:${bg};color:${fg}\"><span class=\"price-text\">${fmtMoney(val)}</span></td><td class=\"trend-cell\">${trendHtml}</td></tr>`}gridEl.innerHTML=html}
async function loadForPostcode(pc){statusEl.textContent='Resolving region…';const gsp=await getGspByPostcode(pc);const now=new Date();const startOfToday=new Date(now);startOfToday.setHours(0,0,0,0);const endOfTomorrow=new Date(now);endOfTomorrow.setDate(now.getDate()+1);endOfTomorrow.setHours(23,59,59,999);const from=startOfToday.toISOString();const to=endOfTomorrow.toISOString();statusEl.textContent=`Region ${gsp}. Fetching rates…`;const rates=await fetchRates(gsp,from,to);await render(rates);statusEl.textContent=`Region ${gsp}. v${VERSION}`}
form.addEventListener('submit',async e=>{e.preventDefault();const pc=postcodeInput.value.trim();if(!pc)return;try{savePostcode(pc);await loadForPostcode(pc)}catch(err){statusEl.textContent=err.message}});(async function init(){const pc=loadInitialPostcode();if(pc){postcodeInput.value=pc;try{await loadForPostcode(pc)}catch(e){statusEl.textContent=e.message}}else{statusEl.textContent='Enter a UK postcode to load Agile rates.'}})();
